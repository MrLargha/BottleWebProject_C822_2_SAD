% rebase('layout.tpl', title=title, year=year)

<h2 style="text-align: center">{{ title }}.</h2>
<h3 style="text-align: center">{{ message }}</h3>
<br>
<h3 class="pretty-h3"><b>Теория</b></h3>
<h4 class="pretty-h4"><b>Определения</b></h4>
<p class="pretty-p"><b>Эйлеров путь</b> - путь, который проходит по каждому ребру, причем ровно один раз.</p>
<p class="pretty-p"><b>Эйлеров цикл</b> - замкнутый Эйлеров путь.</p>
<p class="pretty-p">Граф называется <b>эйлеровым</b>, если он содержит эйлеров цикл. Граф называется
    <b>полуэйлеровым</b>, если он содержит эйлеров путь, но не содержит эйлеров цикл.</p>
<h4 class="pretty-h4"><b>Эйлеровость графа</b></h4>
<p class="info-p">Согласно теореме, доказанной Эйлером, эйлеров цикл существует тогда и только тогда, когда граф связный
    и в нём отсутствуют вершины нечётной степени.</p>
<h4 class="pretty-h4"><b>Описание алгоритма</b></h4>
<p class="info-p">
    Алгоритм находит Эйлеров цикл как в ориентированном, так и в неориентированном графе. Перед запуском алгоритма
    необходимо проверить граф на наличие эйлерового цикла.
    Алгоритм напоминает поиск в глубину. Главное отличие состоит в том, что пройденными помечаются не вершины, а ребра
    графа. Начиная со стартовой вершины строим путь, добавляя на каждом шаге не пройденное еще ребро, смежное с текущей
    вершиной. Вершины пути накапливаются в стеке. Когда наступает такой момент, что для текущей вершины все инцидентные
    ей ребра уже пройдены, записываем вершины из стека в ответ, пока не встретим вершину, которой инцидентны не
    пройденные еще ребра. Далее продолжаем обход по не посещенным ребрам.
</p>
<h4 class="pretty-h4"><b>Алгоритм</b></h4>
<div
    style="font-family: monospace, monospace; tab-size: 4; background-color: #f8f9fa; line-height: 1.3;">
    <pre style="font-size: 11.5pt;">
   1. stack St;
   2. в St кладём любую вершину (стартовая вершина);
   3. <b>ПОКА</b> St не пустой
   4.     пусть V - значение на вершине St;
   5.     <b>ЕСЛИ</b> степень(V) = 0, то
   6.         добавляем V к ответу;
   7.         снимаем V с вершины St;
   8.     <b>ИНАЧЕ</b>
   9.         находим любое ребро, выходящее из V;
  10.         удаляем его из графа;
  11.         второй конец этого ребра кладём в St;</pre>
</div>
<h3 class="pretty-h3" style="margin-top: 80px"><b>Проверить работу алгоритма</b></h3>
<form class="form" method="post" action="/eulerian_loop" style="text-align: center">
    <label>
        <label style="padding: 20px">Количество вершин графа</label>
        <input style="padding: 15px" type="number" class="nice-text-area" name="MATRIX" max="20" min="1">
    </label>
    <p>
        <button class="nice-button" type="submit" value="Выполнить">Ввести граф</button>
    </p>
</form>